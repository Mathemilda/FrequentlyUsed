import keras
import tensorflow as tf


class UniformNoise(tf.keras.layers.Layer):
    """
    Add uniform noise to data.
    Noise can be given as a range or it can be given as level.
    Then it will be transformed into the range inside the class.
    """
    def __init__(self, shape, noise):
        self.shape = shape
        if isinstance(noise, list):
            self.noise_range = noise
        else:
            self.noise_range = [-noise, noise]
        super(UniformNoise, self).__init__()

    def call(self, inputs, training=None):
        if training:
            noise = tf.random.uniform(shape=tf.shape(inputs),
                                      minval=self.noise_range[0],
                                      maxval=self.noise_range[1])
            return inputs + noise
        else:
            return inputs

    def compute_output_shape(self, shape):
        return (input_shape[0], self.output_dim)


class ShearRotate(tf.keras.layers.Layer):
    """
    Apply random shear and rotation to inputs.

    Shear and rotation parameters must be floats.
    """

    def __init__(self, shape, vert_shear, hor_shear, rotation):
        self.shape = shape
        self.vert_shear = vert_shear
        self.hor_shear = hor_shear
        self.rotation = rotation
        super(ShearRotate, self).__init__()

    def build(self, input_shape):
        hor_shear = tf.random.uniform(shape=[1],
                                  minval=-self.hor_shear,
                                  maxval=self.hor_shear)
        vert_shear = tf.random.uniform(shape=[1],
                                  minval=-self.vert_shear,
                                  maxval=self.vert_shear)
        upper_left = 1 + hor_shear*vert_shear
        self.shear_matr = tf.concat([tf.stack([upper_left, hor_shear],
                                        axis=1),
                              tf.stack([vert_shear, tf.constant([1.])],
                                       axis=1)],
                              axis=0)
        angle = tf.random.uniform(shape=[1], 
                                 minval=-self.rotation,
                                 maxval=self.rotation)
        r_cos = tf.cos(angle)
        r_sin = tf.sin(angle)
        self.rotation_matr = tf.concat([tf.stack([r_cos, r_sin], axis=1),
                                  tf.stack([-r_sin, r_cos], axis=1)],
                                 axis=0)

    def call(self, inputs, training=None):
        if training:
            center = tf.reduce_mean(inputs, axis=-2, keepdims=True)
            # I want to collapse a dimension where we enumerate pts.
            centered = inputs - center
            tnsr = tf.matmul(centered, self.rotation_matr)
            tnsr = tf.matmul(centered, self.shear_matr)
            tnsr = tnsr + center
            return tnsr
        else:
            return inputs

